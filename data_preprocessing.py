# -*- coding: utf-8 -*-
"""data_preprocessing.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1KOLBAlRA8l8S_UHYZ8y0K4c3a6-VIyA4

#Librería con funciones para cargar imágenes y realizar preprocesado.
"""

###################################################################################################################################################################################

import tensorflow as tf
from keras.preprocessing.image import ImageDataGenerator, load_img, img_to_array
from glob import glob
import seaborn as sns
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import cv2
import imutils
from sklearn.model_selection import train_test_split

"""#######################################################################################################


Función 'set_split()':

Para preparar las rutas a cada imagen en dataframes. 

* Argumentos:

      - path:  ruta de la carpeta (string)
      - list_target:  es una lista con los nombres de las carpetas que corresponden con las clases. Si queremos que no se coja como nombre de clase el nombre de la carpeta se puede pasar una tupla ('nombre carpeta','nombre clase')  (string)  o  ((string,string))
      - size_split:  si este valor es diferente de cero se hace un train_test_split para obtener dos conjuntos de datos de uno, obtenemos dos dataframes. Si el valor es igual a cero devuelve solo un dataframe con las rutas y las clases (numeric)

* Devolución:

      - dataframe: 
          * Con dos columnas: 'filepath' (ruta a la imagen) y 'class' (nombre de la clase)
"""

def set_split (path,list_target,size_split):

  total_files=[]
  classes=[]

  if isinstance(list_target, list):

    for i,target in enumerate(list_target):

      if isinstance(target, str):

        files = glob(path+target+'/*')
        total_files=total_files+files
        classes=classes+[target]*len(files)
        
      elif isinstance(target, tuple):

        folder,t=target
        if isinstance(folder, str) and isinstance(t, str):

          files = glob(path+folder+'/*')
          total_files=total_files+files
          classes=classes+[t]*len(files)

        else:
          print(f'\nThe elements of the tuple {i} must be a text string. This data has been disregarded.')

      else:
        print(f'\nThe element at position {i} in the list is not a string or a tuple. This data has been disregarded.')

    
    df  = pd.DataFrame({"filepath":total_files, "class":classes})
  
    if size_split!=0:
    
      df_train, df_val = train_test_split(df, test_size=size_split,random_state=123,shuffle=True,stratify=df['class'])
      df_train=df_train.sort_values('class')
      df_val=df_val.sort_values('class')

      return df_train,df_val

    else:

      df=df.sort_values('class')
      return df

  else: 

    print("\nThe second argument must be a list of class names corresponding to each folder or a list of tuples with the folder name and the name you want for the class.")
    df  = pd.DataFrame({"filepath":total_files, "class":classes})
    return df,df

"""#######################################################################################################


Función 'show_images_class()':

Para mostrar varios ejemplos de cada clase. 

* Argumentos:

      - dataframe:  dataframe sobre el que sacar las imágenes
      
"""

def show_images_class(dataframe):

  df_show=dataframe.sample(frac=1.0).groupby('class').head(5).sort_values('class')

  fig=plt.figure(figsize=(15,15))
  fig.subplots_adjust(wspace = 0.2)

  for i,index in enumerate(df_show.index): 

    plt.subplot(4, 5, i+1)
    img = load_img(df_show['filepath'][index],target_size=(150,150))
    plt.imshow(img)
    plt.xlabel(df_show['class'][index], fontsize=14)
    plt.xticks([])
    plt.yticks([])
    
  plt.show()

"""#######################################################################################################


Función 'countplot_classes()':

Para mostrar cuantos ejemplos hay de cada clase. 

* Argumentos:

      - dataframe:  dataframe sobre el que operar
      - target:  nombre de la columna (string)


"""

###################################################################################################################################################################################

#Función para mostrar cuantos ejemplos hay de cada clase. 

#Argumentos:
#  - 'dataframe':  dataframe sobre el que operar
#  - 'target':  nombre de la columna (string)

def countplot_classes (dataframe,target):

  dataframe=dataframe.sort_values(by=[target])
  plt.style.use('seaborn')
  plt.figure(figsize=(10,6))

  sns.set(font_scale=1.3)

  ax=sns.countplot(x=dataframe[target])
  
  ax.set_xticklabels(ax.get_xticklabels(), fontsize=14)
  ax.set_xlabel('')
  ax.set_ylabel("count",fontsize=20)
  ax.set_title('Number of samples per class',size=25)

  series=100*dataframe[target].value_counts()/dataframe[target].shape[0]
  series=series.sort_index()

  total = series.shape[0]
  for i,p in enumerate(ax.patches):
    percentage = f'{series[i].round(2)}%\n'
    x = p.get_x() + p.get_width() / 2
    y = p.get_height()/2
    ax.annotate(percentage, (x, y), ha='center', va='center',color='k',size=20,weight='bold')

  plt.show()

"""#######################################################################################################


Función 'extreme_points_contours()':

Para recortar el objeto principal de la imagen.

https://www.pyimagesearch.com/2016/04/11/finding-extreme-points-in-contours-with-opencv/

* Argumentos:

      - image:  imagen para recortar (imagen)
      - img_size:  tamaño de la imagen ((int,int))
      - generator:  booleano que indica si la función se va a pasar al generador 'ImageDataGenerator'

* Devolución:

  . Si se va a pasar al generador 'ImageDataGenerator'
      - img_clop:  imagen recortada

  . Si no se va a pasar al generador 'ImageDataGenerator'
      - img: imagen original 
      - img_cnt: imagen con el contorno dibujado sobre el objeto
      - img_pnt: imagen con el contorno dibujado sobre el objeto y los 4 puntos extremos señalados
      - img_clop: imagen recortada
"""

def extreme_points_contours(image,img_size=(224,224),generator=True):

# Si la función se va a pasar al generador 'ImageDataGenerator'... 
  if generator: 
    image = image.astype(np.uint8) # hay que pasar la imagen a 'uint8' porque el generador la trata como 'float32' y en la función la necesitamos como 'uint8'
  

# Redimensión de la imagen, convertirla a escala de grises y desenfocarla ligeramente
  img = cv2.resize(image,dsize=img_size,interpolation=cv2.INTER_CUBIC) 
  gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY) 
  gray = cv2.GaussianBlur(gray, (5, 5), 0) 


# Umbral de la imagen, nos permite segmentar la región de la mano del resto de la imagen. 
# Para cada píxel, se aplica el mismo valor de umbral. Si el valor de píxel es menor que el umbral, se establece en 0; de lo contrario, se establece en un valor máximo
# Erosiones y dilataciones para eliminar cualquier pequeña región de ruido 
  thresh = cv2.threshold(gray, 25, 255, cv2.THRESH_BINARY)[1] # Nos deja el objeto principal en blanco y el fondo en negro
  thresh = cv2.erode(thresh, None, iterations=2) # Quita el ruido pero encoje la region blanca principal
  thresh = cv2.dilate(thresh, None, iterations=2) # Al encoger hacemos la dilatación de la región blanca


# Encontrar los contornos en la imagen umbralizada, y luego ordenar los contornos para encontrar el más grande
  cnts = cv2.findContours(thresh.copy(), cv2.RETR_EXTERNAL , cv2.CHAIN_APPROX_SIMPLE)
  cnts = imutils.grab_contours(cnts) # toma el valor de tupla apropiado
  c = max(cnts, key=cv2.contourArea)


# Determinar los puntos más extremos a lo largo del contorno
  extLeft = tuple(c[c[:, :, 0].argmin()][0]) # coordenada x más pequeña (es decir, el valor "oeste") en toda la matriz de contorno C
  extRight = tuple(c[c[:, :, 0].argmax()][0]) # coordenada x más grande (es decir, el valor "este") en toda la matriz de contorno C
  extTop = tuple(c[c[:, :, 1].argmin()][0]) # coordenada y más pequeña (es decir, el valor "norte") en toda la matriz de contorno C
  extBot = tuple(c[c[:, :, 1].argmax()][0]) # coordenada y más grande (es decir, el valor "sur") en toda la matriz de contorno C


# Si la función no se va a pasar al generador 'ImageDataGenerator'.... 
  if generator==False: 
  # Dibuja el contorno del objeto
    img_cnt = cv2.drawContours(img.copy(), [c], -1, (0, 255, 255), 4)

  # Dibujan círculos para cada uno de los puntos extremos en diferentes colores
    img_pnt = cv2.circle(img_cnt.copy(), extLeft, 8, (0, 0, 255), -1)
    img_pnt = cv2.circle(img_pnt, extRight, 8, (0, 255, 0), -1)
    img_pnt = cv2.circle(img_pnt, extTop, 8, (255, 0, 0), -1)
    img_pnt = cv2.circle(img_pnt, extBot, 8, (255, 255, 0), -1)


# Recortar la imagen
  PIXELS = 0 #variable para establecer el numero de pixeles de más que cogemos desde los puntos extremos marcados en el objeto
  img_clop = img[extTop[1]-PIXELS:extBot[1]+PIXELS, extLeft[0]-PIXELS:extRight[0]+PIXELS].copy() #recortamos la imagen

  img_clop=cv2.resize(img_clop,dsize=img_size) # se vuelve a redimensionar la imagen al tamaño establecido porque el recorte ha cambiado el tamaño

# Si la función se va a pasar al generador 'ImageDataGenerator'....
  if generator:  
    img_clop = img_clop.astype(np.float32) # una vez realizado el recorte se vuelve a pasar 'float32' 
    #img_clop=cv2.resize(img_clop,dsize=img_size) # se vuelve a redimensionar la imagen al tamaño establecido porque el recorte ha cambiado el tamaño
  
    return img_clop #se devuelve la imagen final recortada

# Si la función no se va a pasar al generador 'ImageDataGenerator'.... 
  else:
    #img_clop=cv2.resize(img_clop,dsize=img_size)
    return [img,img_cnt,img_pnt,img_clop]  #se devuelven las diferentes imagenes del proceso para poder mostrarlas

"""#######################################################################################################


Función 'show_extreme_points_contours()':

Para mostrar el proceso del recorte de una imagen.

* Argumentos:

      - list_images:  lista de imagenes del proceso
      - tuple_title:  tupla con los titulos de las imágenes


"""

def show_extreme_points_contours(list_images,tuple_title=('Original','Contour','Extreme points','Cropped image')):

  fig=plt.figure(figsize=(15,6))
  fig.subplots_adjust(wspace = 0.2)

  for i,img in enumerate(list_images): 

    plt.subplot(1, len(list_images), i+1)
    plt.imshow(img)
    plt.title(tuple_title[i], fontsize=18)
    plt.xticks([])
    plt.yticks([])

  plt.show()

"""#######################################################################################################


Función 'image_data_generator()':

Para generar el 'ImageDataGenerator'

* Argumentos:

      - preprocess_input:  función de preprocesado que se aplica a todas las imágenes
      - augmentation: si es True se aplica Data Augmentation

* Devolución:

      - datagen: 'ImageDataGenerator'


"""

def image_data_generator(preprocess_input,augmentation=False):

  if augmentation:
    datagen = ImageDataGenerator(dtype='float32',
                                 preprocessing_function = preprocess_input,
                                 rotation_range=40, 
                                 width_shift_range=0.2,
                                 height_shift_range=0.2,
                                 fill_mode='nearest',
                                 shear_range=0.1,
                                 zoom_range=0.1,
                                 rescale=1./255,
                                 horizontal_flip=True,
                                 #brightness_range=[0.1, 0.5],
                                 )
    
  else:
    datagen = ImageDataGenerator(dtype='float32',
                                 preprocessing_function = preprocess_input,
                                 rescale=1./255
                                 )
    
  return datagen

"""#######################################################################################################


Función 'image_data_generator()':

Para crear los generadores por lotes desde las rutas a cada imagen desde un dataframe

* Argumentos:

      - datagen:  'ImageDataGenerator'
      - dataframe:  dataset 
      - img_size:  tupla del tamaño de la imagen ((int,int))
      - batch_size:  tamaño de batch (int)
      - suff:  True para barajar el dataset
      - mode:  modo de codificación de la target 
            * 'binary': 0/1. 
            * 'sparse': entero a partir de 0. 
            * 'categorical': one hot

* Devolución:

      - generator: generador por lotes
"""

def generator_from_dataframe(datagen,dataframe,img_size,batch_size,suff=False,mode='sparse'):
      
  generator = datagen.flow_from_dataframe(dataframe=dataframe, # dataframe
                                          x_col = "filepath", # la ruta que es donde estan las imagenes (nuestras features) esta en la columna 'filepath' del dataframe
                                          y_col = "class", # la target, nuestra clase esta en la columna 'class' del dataframe
                                          target_size=img_size,
                                          batch_size=batch_size,
                                          shuffle=suff,
                                          class_mode=mode # binary: 0/1. Sparse: entero a partir de 0. Categorical: one hot
                                          ) 
  
  return generator